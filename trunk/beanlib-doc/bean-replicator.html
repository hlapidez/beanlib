<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>BeanReplicator</title>
  <style type="text/css">
<!--
body,td,th {
	font-family: Arial, Helvetica, sans-serif;
}
-->
  </style>
</head><body>
<h1>Beanlib - BeanReplicator </h1>
Replicate JavaBean's with ease.
<h2>BeanReplicator: Quick Start</h2>
To replicate a simple JavaBean with a class definition like:
<pre><blockquote>public class SimpleBean {
    private String name;

    public SimpleBean() {}
    public SimpleBean(String name) { this.name = name; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}
...
SimpleBean from = new SimpleBean("foo");
</blockquote></pre>is a simple matter of:
<pre><blockquote>SimpleBean to = new BeanReplicator().replicateBean(from);
</blockquote></pre>
Notes a no-arg constructor is required.
<p>But is that going to work for a more complex JavaBean ?  Let's try:
<pre><blockquote>public class ComplexBean {
    private String name;
    private ComplexBean[] array;
    private Collection&lt;ComplexBean> collection;
    private Map&lt;String,ComplexBean> map;

    public ComplexBean() {}
    public ComplexBean(String name) { this.name = name; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public Collection&lt;ComplexBean> getCollection() { return collection; }
    public void setCollection(Collection&lt;ComplexBean> collection) { this.collection = collection; }

    public ComplexBean[] getArray() { return array; }
    public void setArray(ComplexBean[] array) { this.array = array; }

    public Map&lt;String, ComplexBean> getMap() { return map; }
    public void setMap(Map&lt;String, ComplexBean> map) { this.map = map; }
}
</blockquote></pre>First, set up the bean
<pre><blockquote>ComplexBean from = new ComplexBean("foo");
ComplexBean[] a = { from };
Collection&lt;ComplexBean> col = Arrays.asList(a);
from.setArray(a);
from.setCollection(col);
Map&lt;String,ComplexBean> map = new HashMap&lt;String,ComplexBean>();
map.put(from.getName(), from);
from.setMap(map);
</blockquote></pre>
It can be replicated in the same way:
<pre><blockquote>ComplexBean to = new BeanReplicator().replicateBean(from);
<blockquote></pre>
Voila!  The "to" and "from" beans are different object instances, 
but the content (ie the entire object graph) has been replicated.
Note this works as long as these objects follow the JavaBean convention.
See <a 
href="http://beanlib.svn.sourceforge.net/viewvc/beanlib/trunk/beanlib-test/src/net/sf/beanlib/provider/replicator/BeanReplicatorTest.java?revision=283&view=markup"
>BeanReplicatorTest.java</a> for more details.
</pre>
<h2>BeanReplicator: Customizing Behavior</h2>
The default behavior of BeanReplicator can be customized via various options.
<h3>Getters and Setters</h3>
By default, only the setter methods of the target bean are invoked for property propagation.  
Say you want to expand that to include protected and private methods:
<pre><blockquote>BeanTransformerSpi t = new BeanTransformer().initSetterMethodCollector(new PrivateSetterMethodCollector());
Object fromBean = ...
Object toBean = new BeanReplicator(t).replicateBean(fromBean);
</blockquote></pre>
Now setter methods on the toBean will be invoked with values retrieved from invoking the respective public getter methods of the fromBean.
<p>
A similar example of expanding the default behavior of retrieving property values from the public getter methods:
<pre><blockquote>BeanTransformerSpi t = new BeanTransformer().initReaderMethodFinder(new PrivateReaderMethodFinder());
Object fromBean = ...
Object toBean = new BeanReplicator(t).replicateBean(fromBean);
</blockquote></pre>
Now values will be retrieved from invoking all getter methods (including protected and private) on the fromBean.
<h3>Property Filter</h3>
You can specify a property filter to filter out those properties that you don't want to be propagated.  
Once filtered out, the getter method will not even be invoked on the property.
<p>
For example, if for some reason any property that is named "foo" should be filtered out (ie not propagated),
it can be achieved like so:
<pre><blockquote>PropertyFilter propertyFilter = new PropertyFilter() {
    public boolean propagate(String propertyName, Method readerMethod) {
        return !"foo".equals(propertyName);
    }
};
BeanTransformerSpi t = new BeanTransformer().initPropertyFilter(propertyFilter);
Object fromBean = ...
Object toBean = new BeanReplicator(customTransformer).replicateBean(fromBean);
</blockquote></pre>
<h3>Detailed Property Filter</h3>
Just like a Property Filter, a Detailed Property Filter serves the same purpose but is provided with additional contextual informtion
about the property that is under consideration.
<p>
For a convoluted example, if for some reason any property that is named "foo" should be filtered out (ie not propagated)
unless the "foo" property belongs to a class named "Bar", it can be achieved like so:
<pre><blockquote>DetailedPropertyFilter detailedPopertyFilter = new DetailedPropertyFilter() {
    public boolean propagate(String propertyName, Object fromBean, Method readerMethod, 
                                                  Object toBean,   Method setterMethod) 
    {
        return !"foo".equals(propertyName) || Bar.class == fromBean.getClass();
    }
};
BeanTransformerSpi t = new BeanTransformer().initDetailedPropertyFilter(detailedPropertyFilter);
Object fromBean = ...
Object toBean = new BeanReplicator(t).replicateBean(fromBean);
</blockquote></pre>
<h3>Custom Bean Transformer</h3>

(TODO: See CustomBeanTransformerSpi for how to write and configure your own custom transformer.)
<p>
(TODO: See javadoc for more details.)
<!--
Various options exist in overriding the default behavior of BeanReplicator via the BeanTransformerSpi:
<ol>
<li>To decide on whether a JavaBean property should be populated or not via the BeanPopulatable SPI.
For example,
<blockquote><pre>
BeanPopulatable myPopulatable = ...

ComplexBean to = new BeanReplicator(myTranformer).replicateBean(from);
</pre></blockquote>
</li>
<p>
<li>Shallow clone which will result in cloning the top level bean and the immediately contained member fields of Java primitive types, String, Date, etc., but will exclude instances of Collection and application specific types. The excluded member fields will be set to null;</li>
<p>
<li>Partial deep clone that extends only to a specified set of classes and a specified set of "collection properties". A collection property can be specified via a class named CollectionPropertyName. This allows an arbitrary portion of the object graph to be deeply cloned;</li>
<p>
<li>Provide your own customized "Vetoer" by implementing the BeanPopulatable interface to control the population decision of each bean property;</li>
<p>
<li>Provide your own customized BeanPopulatable and/or DetailedBeanPopulatable to completely override the population decision of each bean property.</li>
</ol>
-->
</body></html>
