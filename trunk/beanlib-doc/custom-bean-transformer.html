<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>CustomBeanTransformer SPI</title>
  <style type="text/css">
<!--
body,td,th {
	font-family: Arial, Helvetica, sans-serif;
}
-->
  </style>
</head><body>
<h1>Beanlib - CustomBeanTransformer SPI</h1>
Custom bean transformer is about plugging in custom code to partially override the behavior of how the content 
of a "from" JavaBean gets populated across to that of the target JavaBean.
<h2>Customizing BeanReplicator</h2>
For example, by default when BeanReplicator is populating the content of the target bean, 
it would try to instantiate classes using the no-arg constructor.  
This would cause a NoSuchMethodException when a class such as Point below is instantiated:
<pre><blockquote>public class Point {
    private final int x, y;
    
    // missing no-arg constructor 
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public int getX() { return x; }
    public int getY() { return y; }
}

public class Bean {
    private Point point;
    public Point getPoint() { return point; }
    public void setPoint(Point point) { this.point = point; }
}

...
// Initialize a bean
Bean from = new Bean();
from.setPoint(new Point(1,2));

// Tries to replicate the bean via the default replicator
BeanReplicator replicator = BeanReplicator.newBeanReplicatable();
// Will cause NoSuchMethodException, as Point does not have a no-arg constructor
Bean to = replicator.replicateBean(from);
</blockquote></pre>One way to get around this problem is to define a custom transformer and the respective factory:
<pre><blockquote>public class MyBeanTransformer implements CustomBeanTransformerSpi {
    public  boolean isTransformable(Object from, Class toClass, PropertyInfo propertyInfo) {
        return toClass == Point.class;
    }
    
    public <T> T transform(Object in, Class<T> toClass, PropertyInfo propertyInfo) {
        Point from = (Point)in;
        // Note the framework takes care of the issue of object identity,
        // so we don't need to here.
        return (T)new Point(from.getX(), from.getY());
    }
}

public class MyBeanTransformerFactory implements CustomBeanTransformerSpi.Factory {
    public CustomBeanTransformerSpi newCustomBeanTransformer(BeanTransformerSpi beanTransformer) {
        return new MyBeanTransformer();
    }
}

...
// Initialize a bean
Bean from = new Bean();
from.setPoint(new Point(1,2));

// Partially overrides the default transformer behavior
BeanTransformerSpi transformer = BeanTransformer.newBeanTransformer();
transformer.initCustomTransformerFactory(new MyBeanTransformerFactory());
BeanReplicator replicator = BeanReplicator.newBeanReplicatable(transformer);

// Replicates the bean
Bean to = replicator.replicateBean(from); // now works!
</blockquote></pre>
<h2>Customizing HibernateBeanReplicator</h2>
Customizing the behavior of HibernateBeanReplicator is basically identical to that of BeanReplicator as decribed above.
For example, assuming the same MyBeanTransformerFactory defined above is used,
<pre><blockquote>// Partially overrides the default Hibernate bean transformer's behavior
HibernateBeanReplicator replicator = new Hibernate3BeanReplicator();
replicator.initCustomTransformerFactory(new MyBeanTransformerFactory());
replicator.copy(...);
</blockquote></pre>
</body></html>
